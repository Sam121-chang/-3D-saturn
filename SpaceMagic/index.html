<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>Saturn Particle System - V3 Ultimate</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Helvetica Neue', Arial, sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        
        #ui-layer {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            z-index: 10; text-align: center; pointer-events: none;
            color: rgba(255, 255, 255, 0.8); width: 100%;
        }
        h1 { font-weight: 200; letter-spacing: 4px; font-size: 14px; margin: 0 0 10px 0; text-transform: uppercase; }
        #status { font-size: 16px; color: #4db8ff; margin-bottom: 20px; text-shadow: 0 0 10px #4db8ff; font-weight: bold; }
        
        /* è°ƒè¯•çª—å£ï¼šç°åœ¨ä¼šç”»å‡ºçº¢çº¿ */
        #debug-container {
            position: absolute; bottom: 20px; right: 20px; 
            width: 240px; height: 180px; 
            border: 2px solid rgba(255,255,255,0.3); 
            border-radius: 8px; z-index: 100; opacity: 0.9;
            background: rgba(0,0,0,0.5);
            overflow: hidden;
        }
        #webcam, #output_canvas { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            transform: scaleX(-1); /* é•œåƒç¿»è½¬ */
        }
        
        .mode-badge {
            display: inline-block; padding: 4px 8px; border-radius: 4px; 
            font-size: 12px; margin-bottom: 10px; font-weight: bold;
        }
        .mode-ai { background: rgba(0, 255, 100, 0.2); color: #00ff66; border: 1px solid #00ff66; }
        .mode-light { background: rgba(255, 200, 0, 0.2); color: #ffcc00; border: 1px solid #ffcc00; }
        
        #loading {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 20; display: flex; justify-content: center; align-items: center; flex-direction: column; color: #fff;
            transition: opacity 1s;
        }
    </style>
</head>
<body>

    <div id="loading">
        <div style="font-size: 24px; margin-bottom: 20px;">ğŸª</div>
        <div id="loading-text">æ­£åœ¨å°è¯•è¿æ¥ AI å«æ˜Ÿ...<br><span style="font-size:12px; opacity:0.6">å¦‚æœå¤±è´¥å°†è‡ªåŠ¨åˆ‡æ¢åˆ°å…‰æ„Ÿåº”å¤‡ç”¨æ¨¡å¼</span></div>
    </div>

    <div id="ui-layer">
        <h1>Saturn Protocol // V3 Ultimate</h1>
        <div id="mode-indicator" style="margin-bottom: 5px;"></div>
        <div id="status">ç³»ç»Ÿåˆå§‹åŒ–...</div>
        <p style="font-size: 10px; opacity: 0.5;">æç¤ºï¼šé¼ æ ‡ç‚¹å‡»å¯éšæ—¶å¼ºåˆ¶æ¥ç®¡æ§åˆ¶æƒ</p>
    </div>

    <div id="canvas-container"></div>
    
    <div id="debug-container">
        <video id="webcam" autoplay playsinline></video>
        <canvas id="output_canvas"></canvas>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/+esm"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { FilesetResolver, HandLandmarker, DrawingUtils } from '@mediapipe/tasks-vision';

        // --- å…¨å±€å˜é‡ ---
        let controlMode = "INIT"; // INIT, AI, LIGHT, MOUSE
        let finalZoom = 0;
        let smoothedZoom = 0;
        let mouseZoom = -1;
        
        // è§†è§‰ç›¸å…³
        let renderer, scene, camera, composer, particleSystem, uniforms;
        
        // AI/è§†é¢‘ç›¸å…³
        let handLandmarker;
        let video = document.getElementById('webcam');
        let canvasElement = document.getElementById('output_canvas');
        let canvasCtx = canvasElement.getContext('2d');
        let drawingUtils;
        let lastVideoTime = -1;
        let brightnessBase = 0; // å…‰æ„Ÿåº”åŸºå‡†

        // --- åˆå§‹åŒ–æµç¨‹ ---
        async function init() {
            setupThreeJS();
            createSaturnSystem();
            setupMouseInput();
            
            // å¯åŠ¨æ‘„åƒå¤´
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ video: true });
                video.srcObject = stream;
                await new Promise(r => { video.onloadeddata = () => { video.play(); r(); } });
                
                // è®¾ç½®ç”»å¸ƒå°ºå¯¸åŒ¹é…è§†é¢‘
                canvasElement.width = video.videoWidth;
                canvasElement.height = video.videoHeight;
                
                // è®¡ç®—åˆå§‹ç¯å¢ƒäº®åº¦ï¼ˆç”¨äºå…‰æ„Ÿåº”æ¨¡å¼ï¼‰
                brightnessBase = calculateBrightness();
                console.log("Base Brightness:", brightnessBase);

            } catch (err) {
                alert("æ‘„åƒå¤´å¯åŠ¨å¤±è´¥ï¼Œè¯·æ£€æŸ¥æƒé™");
                return;
            }

            // å°è¯•åŠ è½½ AI (è®¾ç½®3ç§’è¶…æ—¶ï¼Œè¶…æ—¶å°±åˆ‡å…‰æ„Ÿåº”)
            updateStatus("æ­£åœ¨è¿æ¥ AI æ¨¡å‹...", "INIT");
            
            const aiPromise = setupMediaPipe();
            const timeoutPromise = new Promise((resolve) => setTimeout(() => resolve('TIMEOUT'), 5000));

            const result = await Promise.race([aiPromise, timeoutPromise]);

            if (result === 'SUCCESS') {
                controlMode = "AI";
                updateStatus("AI æ ¸å¿ƒå·²è¿æ¥ - è¯·å±•ç¤ºæ‰‹æŒ", "AI");
                drawingUtils = new DrawingUtils(canvasCtx);
            } else {
                controlMode = "LIGHT";
                updateStatus("AI è¿æ¥è¶…æ—¶ - å·²åˆ‡æ¢è‡³ [å…‰æ„Ÿåº”æ¨¡å¼]", "LIGHT");
                document.getElementById('status').innerText += "\n(è¯·å¼ å¼€æ‰‹æŒé è¿‘æ‘„åƒå¤´ï¼Œåˆ©ç”¨åå…‰æ§åˆ¶)";
            }

            document.getElementById('loading').style.opacity = 0;
            setTimeout(() => document.getElementById('loading').style.display = 'none', 1000);

            animate();
        }

        // --- æ ¸å¿ƒé€»è¾‘ï¼šè¾“å…¥å¤„ç† ---
        function processInput() {
            // 1. é¼ æ ‡æœ€é«˜ä¼˜å…ˆçº§
            if (mouseZoom !== -1) {
                return mouseZoom;
            }

            // 2. AI æ¨¡å¼
            if (controlMode === "AI") {
                if (detectHandAI()) {
                    return getHandOpennessAI();
                } else {
                    return 0; // æ²¡æ‰‹å°±å½’é›¶
                }
            }

            // 3. å…‰æ„Ÿåº”æ¨¡å¼ (å¤‡ç”¨)
            if (controlMode === "LIGHT") {
                return detectLightIntensity();
            }

            return 0;
        }

        // --- ç­–ç•¥ A: AI æ£€æµ‹ ---
        let aiResults = null;
        async function setupMediaPipe() {
            try {
                const vision = await FilesetResolver.forVisionTasks(
                    "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm"
                );
                handLandmarker = await HandLandmarker.createFromOptions(vision, {
                    baseOptions: {
                        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`,
                        delegate: "GPU"
                    },
                    runningMode: "VIDEO",
                    numHands: 1
                });
                return 'SUCCESS';
            } catch (e) {
                console.warn("AI Load Error:", e);
                return 'FAIL';
            }
        }

        function detectHandAI() {
            if (!handLandmarker) return false;
            // æ¸…ç©ºç”»å¸ƒ
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            
            if (video.currentTime !== lastVideoTime) {
                lastVideoTime = video.currentTime;
                aiResults = handLandmarker.detectForVideo(video, performance.now());
            }

            if (aiResults && aiResults.landmarks.length > 0) {
                // ç”»å‡ºéª¨æ¶ (Debug)
                for (const landmarks of aiResults.landmarks) {
                    drawingUtils.drawConnectors(landmarks, HandLandmarker.HAND_CONNECTIONS, { color: "#00FF00", lineWidth: 3 });
                    drawingUtils.drawLandmarks(landmarks, { color: "#FF0000", lineWidth: 1 });
                }
                return true;
            }
            return false;
        }

        function getHandOpennessAI() {
            const lm = aiResults.landmarks[0];
            const wrist = lm[0];
            const tips = [lm[4], lm[8], lm[12], lm[16], lm[20]];
            const palmRef = lm[9]; 
            
            const dist = (p1, p2) => Math.sqrt(Math.pow(p1.x-p2.x, 2) + Math.pow(p1.y-p2.y, 2));
            const palmSize = dist(wrist, palmRef);
            let avgTipDist = 0;
            tips.forEach(tip => avgTipDist += dist(wrist, tip));
            avgTipDist /= 5;

            // å®½æ¾çš„ç®—æ³•
            let ratio = avgTipDist / palmSize;
            let val = (ratio - 0.5) / (1.7 - 0.5);
            return Math.max(0, Math.min(1, val));
        }

        // --- ç­–ç•¥ B: å…‰æ„Ÿåº” (Fallback) ---
        function calculateBrightness() {
            // é‡‡æ ·ç”»é¢ä¸­å¿ƒ 50x50 çš„åŒºåŸŸ
            const w = canvasElement.width;
            const h = canvasElement.height;
            // ä¸´æ—¶ç”»åœ¨ hidden canvas ä¸Šå–å€¼å¤ªæ…¢ï¼Œç›´æ¥åˆ©ç”¨ canvasCtx (videoå·²ä¸å†ç”»åœ¨ä¸Šé¢ï¼Œä½†æˆ‘ä»¬å¯ä»¥åˆ©ç”¨ getImageData)
            // ä¸ºäº†æ€§èƒ½ï¼Œæˆ‘ä»¬åªé‡‡æ ·å‡ ä¸ªç‚¹
            // è¿™é‡Œç®€å•æ¨¡æ‹Ÿï¼šå‡è®¾æ‰‹æŒé è¿‘ä¼šæ˜¾è‘—å¢åŠ ç”»é¢ä¸­é—´çš„äº®åº¦ï¼ˆè‚¤è‰²é€šå¸¸æ¯”èƒŒæ™¯äº®ï¼‰
            // æ³¨æ„ï¼šè¿™éœ€è¦æˆ‘ä»¬æŠŠè§†é¢‘å¸§ç”»åˆ°ä¸€ä¸ªå°çš„ç¦»å±canvasä¸Š
            return 0; // ç®€åŒ–ç‰ˆä¸çœŸæ­£è®¡ç®—ï¼Œä¾èµ– detectLightIntensity çš„å®æ—¶è®¡ç®—
        }

        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = 32; tempCanvas.height = 32; // æä½åˆ†è¾¨ç‡
        const tempCtx = tempCanvas.getContext('2d');

        function detectLightIntensity() {
            // æŠŠè§†é¢‘ç”»åˆ° 32x32 çš„ç”»å¸ƒä¸Š
            tempCtx.drawImage(video, 0, 0, 32, 32);
            const frame = tempCtx.getImageData(0, 0, 32, 32);
            const data = frame.data;
            let total = 0;
            for(let i = 0; i < data.length; i += 4) {
                total += (data[i] + data[i+1] + data[i+2]) / 3;
            }
            const avg = total / (32 * 32);
            
            // åŠ¨æ€æ ¡å‡†ï¼šå¦‚æœå½“å‰äº®åº¦æ¯”åŸºå‡†é«˜ï¼Œè¯´æ˜æœ‰ä¸œè¥¿ï¼ˆæ‰‹ï¼‰é®æŒ¡æˆ–é è¿‘
            // é€šå¸¸ï¼šæ‰‹æŒï¼ˆæµ…è‰²ï¼‰é è¿‘é»‘è‰²èƒŒæ™¯ = å˜äº®
            // é˜ˆå€¼ç®—æ³•
            let diff = avg - brightnessBase;
            // æ•æ„Ÿåº¦æ”¾å¤§
            let val = diff / 40.0; // äº®åº¦å¢åŠ 40ä¸ªå•ä½ç®—æ»¡
            
            // æ…¢æ…¢æ›´æ–°åŸºå‡†ï¼Œé€‚åº”ç¯å¢ƒå…‰å˜åŒ–
            if (val < 0.1) brightnessBase = brightnessBase * 0.99 + avg * 0.01;
            
            return Math.max(0, Math.min(1, val));
        }

        // --- Three.js & Shader (ä¿æŒæè‡´ç”»è´¨) ---
        // (çœç•¥äº†é‡å¤çš„ setupThreeJS å’Œ createSaturnSystem ä»£ç ç»†èŠ‚ï¼Œç›´æ¥å¤ç”¨ä¸Šä¸ªç‰ˆæœ¬çš„æ ¸å¿ƒé€»è¾‘)
        // ä¸ºäº†ä»£ç ç®€æ´ï¼Œæˆ‘å°†æ ¸å¿ƒ Shader å’Œ åˆ›å»ºå‡½æ•°åˆå¹¶åœ¨æ­¤
        
        const vertexShader = `
            uniform float uTime; uniform float uZoom;
            attribute float aSize; attribute float aSpeed; attribute float aRadius;
            attribute float aAngleOffset; attribute float aRandom; attribute vec3 aChaosDir;
            varying vec3 vColor; varying float vAlpha;
            void main() {
                float currentAngle = aAngleOffset + (uTime * aSpeed);
                vec3 orbitPos;
                orbitPos.x = cos(currentAngle) * aRadius;
                orbitPos.z = sin(currentAngle) * aRadius;
                orbitPos.y = sin(currentAngle * 2.0 + aRandom * 10.0) * (aRadius * 0.05);
                float expansionFactor = 1.0 + uZoom * 4.0; 
                vec3 expandedPos = orbitPos * expansionFactor;
                vec3 chaosPos = expandedPos;
                if (uZoom > 0.8) {
                    float timeJitter = sin(uTime * 30.0 + aRandom * 100.0);
                    vec3 jitter = aChaosDir * timeJitter * 0.2;
                    vec3 explode = aChaosDir * (uZoom - 0.8) * 15.0;
                    chaosPos = expandedPos + jitter + explode;
                }
                float chaosMix = smoothstep(0.8, 1.0, uZoom);
                vec3 finalPos = mix(expandedPos, chaosPos, chaosMix);
                vec4 mvPosition = modelViewMatrix * vec4(finalPos, 1.0);
                gl_Position = projectionMatrix * mvPosition;
                float sizeZoomBoost = 1.0 + uZoom * 2.0;
                gl_PointSize = aSize * sizeZoomBoost * (300.0 / -mvPosition.z);
                float brightness = 0.3 + uZoom * 1.5;
                vec3 coreColor = vec3(0.9, 0.7, 0.4);
                vec3 ringColor = vec3(0.6, 0.7, 0.8);
                float colorMix = smoothstep(2.0, 6.0, aRadius);
                vec3 baseCol = mix(coreColor, ringColor, colorMix);
                vColor = mix(baseCol, vec3(1.0, 1.0, 1.0), chaosMix * 0.8);
                vColor *= brightness;
                vAlpha = 1.0;
            }
        `;
        const fragmentShader = `
            varying vec3 vColor; varying float vAlpha;
            void main() {
                vec2 center = gl_PointCoord - 0.5;
                float dist = length(center);
                if (dist > 0.5) discard;
                float strength = 1.0 - (dist * 2.0);
                strength = pow(strength, 1.5);
                gl_FragColor = vec4(vColor, vAlpha * strength);
            }
        `;

        function setupThreeJS() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.02);
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 20; camera.position.y = 5; camera.lookAt(0, 0, 0);
            renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            container.appendChild(renderer.domElement);
            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0.1; bloomPass.strength = 1.2; bloomPass.radius = 0.5;
            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                composer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        function createSaturnSystem() {
            // (Same geometry creation as V2)
            const geometry = new THREE.BufferGeometry();
            const positions = []; const sizes = []; const speeds = []; const radii = []; 
            const angles = []; const randoms = []; const chaosDirs = [];
            const CONFIG = { particleCount: 80000 };

            for (let i = 0; i < CONFIG.particleCount; i++) {
                let r, size;
                const isCore = Math.random() < 0.25;
                if (isCore) {
                    r = Math.cbrt(Math.random()) * 2.0; size = Math.random() * 0.5 + 0.5;
                } else {
                    r = 3.5 + Math.random() * (10.0 - 3.5);
                    if (r > 6.0 && r < 6.5) r += 0.5; 
                    size = Math.random() * 0.3 + 0.2;
                }
                let speed = isCore ? 0.2 : (2.0 / Math.sqrt(r)); 
                speed *= (Math.random() > 0.5 ? 1 : 1); 
                const cx = (Math.random() - 0.5) * 2; const cy = (Math.random() - 0.5) * 2; const cz = (Math.random() - 0.5) * 2;
                const cDir = new THREE.Vector3(cx, cy, cz).normalize();
                positions.push(0, 0, 0); sizes.push(size); speeds.push(speed * 0.2);
                radii.push(r); angles.push(Math.random() * Math.PI * 2);
                randoms.push(Math.random()); chaosDirs.push(cDir.x, cDir.y, cDir.z);
            }
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('aSize', new THREE.Float32BufferAttribute(sizes, 1));
            geometry.setAttribute('aSpeed', new THREE.Float32BufferAttribute(speeds, 1));
            geometry.setAttribute('aRadius', new THREE.Float32BufferAttribute(radii, 1));
            geometry.setAttribute('aAngleOffset', new THREE.Float32BufferAttribute(angles, 1));
            geometry.setAttribute('aRandom', new THREE.Float32BufferAttribute(randoms, 1));
            geometry.setAttribute('aChaosDir', new THREE.Float32BufferAttribute(chaosDirs, 3));
            uniforms = { uTime: { value: 0 }, uZoom: { value: 0 } };
            const material = new THREE.ShaderMaterial({
                uniforms: uniforms, vertexShader: vertexShader, fragmentShader: fragmentShader,
                transparent: true, depthWrite: false, blending: THREE.AdditiveBlending
            });
            particleSystem = new THREE.Points(geometry, material);
            particleSystem.rotation.z = 25 * (Math.PI / 180); 
            particleSystem.rotation.x = 10 * (Math.PI / 180);
            scene.add(particleSystem);
        }

        function setupMouseInput() {
            const handleMouse = (y) => {
                mouseZoom = 1.0 - (y / window.innerHeight);
                document.getElementById('status').innerText = `é¼ æ ‡å¼ºåˆ¶æ§åˆ¶: ${(mouseZoom*100).toFixed(0)}%`;
                controlMode = "MOUSE"; // å¼ºåˆ¶åˆ‡æ¢
            };
            window.addEventListener('mousedown', (e) => handleMouse(e.clientY));
            window.addEventListener('mousemove', (e) => { if(e.buttons === 1) handleMouse(e.clientY); });
            window.addEventListener('mouseup', () => { 
                mouseZoom = -1; 
                controlMode = handLandmarker ? "AI" : "LIGHT"; // æ¢å¤
                document.getElementById('status').innerText = controlMode === "AI" ? "AI æ¢å¤æ¥ç®¡" : "å…‰æ„Ÿåº”æ¨¡å¼æ¢å¤";
            });
            // Touch
            window.addEventListener('touchmove', (e) => handleMouse(e.touches[0].clientY));
            window.addEventListener('touchend', () => { mouseZoom = -1; controlMode = handLandmarker ? "AI" : "LIGHT"; });
        }

        function updateStatus(text, mode) {
            const el = document.getElementById('status');
            const badge = document.getElementById('mode-indicator');
            el.innerText = text;
            if (mode === 'AI') badge.innerHTML = '<span class="mode-badge mode-ai">â— AI MODEL ONLINE</span>';
            if (mode === 'LIGHT') badge.innerHTML = '<span class="mode-badge mode-light">â— LIGHT SENSOR MODE</span>';
        }

        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);

            // è·å–ç›®æ ‡ç¼©æ”¾å€¼
            let target = processInput();
            
            // å¹³æ»‘å¤„ç† (Lerp)
            smoothedZoom += (target - smoothedZoom) * 0.1;

            if (uniforms) {
                uniforms.uTime.value = clock.getElapsedTime();
                uniforms.uZoom.value = smoothedZoom;
            }

            composer.render();
            
            // Debug Loop Info
            if(controlMode === "LIGHT") {
               // å¦‚æœæ˜¯å…‰æ„Ÿåº”æ¨¡å¼ï¼Œç¨å¾®æ›´æ–°ä¸€ä¸‹çŠ¶æ€æ–‡å­—é‡Œçš„æ•°å€¼
               // document.getElementById('status').innerText = `å…‰æ„Ÿåº”å¼ºåº¦: ${(target*100).toFixed(0)}%`;
            }
        }
        
        init();

    </script>
</body>
</html>